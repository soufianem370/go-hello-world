#!/bin/bash

#########
### DS MySQL RESTORATION SCRIPT
### - Locally restore a MySQL database from GZipped (.gz) or dump (.sql) backup generated by backup.sh script
### - Restoration is done in a temporary database, unless you ask to replace the original database
### Call: ./restore.sh [GZ file containing database to restore]
#########

# Load configuration
. /backup/conf/backup.conf

# Include backup utilities
. /backup/scripts/functions.filesystem.sh
. /backup/scripts/functions.mysql.dumps.sh

# Check if parameters are set
if [ -z $1 ]
then
	echo Please specify the file containing the dump 
	exit 1
fi

# Check if file is specified
if [ ! -f $1 ]; then
	echo "File $1 not found!"
	exit 1
fi

# Get file to restore
DATABASE_FILE=$1

# Extract path
DATABASE_FILE_PATH=$(dirname "${DATABASE_FILE}")

# Get tmp path
DATABASE_TMP_PATH=/data/mysql/tmp

# Extract file name
DATABASE_FILE_NAME=$(basename "${DATABASE_FILE}")

# Detect if GZip
if [ "${DATABASE_FILE_NAME##*.}" == "gz" ]
then
	# Set gzip file name
	DATABASE_FILE_NAME_GZ=${DATABASE_FILE_NAME}

	# Extract SQL file name
	DATABASE_FILE_NAME_SQL=${DATABASE_FILE_NAME%.gz}

	# Set gzip flag
	IS_GZIP=1
else
	# Extract SQL file name
	DATABASE_FILE_NAME_SQL=${DATABASE_FILE_NAME}

	# Set gzip flag
	IS_GZIP=0
fi

# Extract database names
DATABASE_NAME_SOURCE=${DATABASE_FILE_NAME_SQL#dump_}
DATABASE_NAME_SOURCE=${DATABASE_NAME_SOURCE%.sql}
DATABASE_NAME_RESTORE=tmp_${DATABASE_NAME_SOURCE}

# Get used space on disk
DISK_USED_SPACE=`getDataUsedSpace`

# Get total space on disk
DISK_TOTAL_SPACE=`getDataTotalSpace`

# Estimate usable space (80% of total space
DISK_USABLE_SPACE=$(( ${DISK_TOTAL_SPACE}*80/100 ))

# Estimate usable space for restoration
RESTORATION_USABLE_SPACE=$(( ${DISK_USABLE_SPACE} - ${DISK_USED_SPACE} ))

# Get database file size
DATABASE_FILE_SIZE=`getFileSize ${DATABASE_FILE}`

# Estimate restoration file size
DATABASE_ESTIMATED_SIZE=$(( ${DATABASE_FILE_SIZE} * ${COMPRESSION_RATIO} ))

# Display infos
echo -e "\e[1;34m"
echo "-----------------------------------"
echo "  DS Database restoration program  "
echo "-----------------------------------"
echo -e "\e[0m"
echo -e "Source file: \t\t\t \e[1m${DATABASE_FILE}\e[0m"
echo -e "Source file size: \t\t \e[1m${DATABASE_FILE_SIZE}Go\e[0m"
echo -e "Estimated database size: \t \e[1m${DATABASE_ESTIMATED_SIZE}Go\e[0m"
echo -e "Usable space on disk: \t\t \e[1m${RESTORATION_USABLE_SPACE}Go\e[0m"
echo

# Check disk space
if [ $(( ${DATABASE_FILE_SIZE} + ${DATABASE_ESTIMATED_SIZE} )) -lt ${RESTORATION_USABLE_SPACE} ]
then
	echo -e "\e[1;32mDisk space is OK for restoration\e[0m"
else
	echo -e "\e[1;31mThere isn't enough disk space to perform restoration\e[0m"
	echo "Restoration aborted..."
	exit 1
fi

# Restoration confirmation
echo 
echo -e "Database \e[1;34m${DATABASE_NAME_SOURCE}\e[0m will be restored to \e[1;34m${DATABASE_NAME_RESTORE}\e[0m on local MySQL server"
read -p "Is it OK? (y|n) " CHECK_VALID

# Check response
if [ "$CHECK_VALID" = "n" ]
then
	echo
	echo "Restoration aborted..."
	exit 1
elif [ "$CHECK_VALID" = "y" ]
then
	echo ""
else
	echo
	echo "We didn't understand your answer. Restoration aborted..."
	exit 1
fi

# Write to binlog
echo -e "MySQL replication is done through binary logs. You can choose to write or not restoration requests into binary logs."
echo -e "- Restoration \e[1;34mwith binary logs\e[0m: data will be sent on all hosts of the replica -> \e[1;32msafe but long method\e[0m"
echo -e "- Restoration \e[1;34mwithout binary logs\e[0m: data will be restored on this host only -> \e[1;31mfast but unsafe method\e[0m"
read -p "Do you want to write requests to binary logs? (y|n) " WRITE_BINLOGS

# Set binary logs options
if [ "$WRITE_BINLOGS" == "n" ]
then
	DEACTIVATE_BINLOGS="0"
	ACTIVATE_BINLOGS="1"
elif [ "$WRITE_BINLOGS" = "y" ]
then
	DEACTIVATE_BINLOGS="1"
	ACTIVATE_BINLOGS="1"
else
	echo
	echo "We didn't understand your answer. Restoration aborted..."
	exit 1
fi

# Copy source dump on SSD disk if necessary
if [ "`dirname ${DATABASE_FILE}`" == "${DATABASE_TMP_PATH}" ]
then
	echo
	echo -e "`date +%Y-%m-%d\ %H:%M:%S` - \e[1m${DATABASE_FILE}\e[0m already in \e[1m${DATABASE_TMP_PATH}\e[0m, no need to copy"
	echo
else
	echo
	echo -e "`date +%Y-%m-%d\ %H:%M:%S` - Copy \e[1m${DATABASE_FILE}\e[0m to \e[1m${DATABASE_TMP_PATH}\e[0m on SSD disk to go faster"
	cp ${DATABASE_FILE} ${DATABASE_TMP_PATH}/
	echo -e "`date +%Y-%m-%d\ %H:%M:%S` - \e[1m${DATABASE_FILE}\e[0m copied to \e[1m${DATABASE_TMP_PATH}\e[0m"
echo
fi

# Unzip file if is zipped
if [ $IS_GZIP -eq 1 ]
then
	echo "`date +%Y-%m-%d\ %H:%M:%S` - Unzip source file. It can take a while. Please, be patient..."
	gunzip ${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_GZ}
	echo -e "`date +%Y-%m-%d\ %H:%M:%S` - Source file unzipped to \e[1m${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}\e[0m"
	echo
fi

# Drop restore database if already exists
echo "`date +%Y-%m-%d\ %H:%M:%S` - Drop restore database if already exists"
mysql --login-path=local --batch --execute "DROP DATABASE IF EXISTS ${DATABASE_NAME_RESTORE};"

# Create restore database
echo "`date +%Y-%m-%d\ %H:%M:%S` - Create restore database"
mysql --login-path=local --batch --execute "CREATE DATABASE ${DATABASE_NAME_RESTORE};"

# Restore database 
echo "`date +%Y-%m-%d\ %H:%M:%S` - Restore database"
mysql --login-path=local --init-command="SET SESSION sql_log_bin=${DEACTIVATE_BINLOGS};SET SESSION foreign_key_checks=0;SET SESSION unique_checks=0;" ${DATABASE_NAME_RESTORE} < ${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}

# Print result
echo 
echo -e "\e[1;32mRestoration successful\e[0m"
echo

# Ask for replace
echo -e "We can replace the original \e[1;34m${DATABASE_NAME_SOURCE}\e[0m database by \e[1;34m${DATABASE_NAME_RESTORE}\e[0m"
read -p "Do you want to? (y|n) " CHECK_VALID_REPLACE

# Check response
if [ "$CHECK_VALID_REPLACE" = "y" ]
then
	echo
	echo -e "We are going to \e[1;31mdrop and replace\e[0m the original \e[1;34m${DATABASE_NAME_SOURCE}\e[0m database"
	read -p "Are you sure? (y|n) " CHECK_VALID_AGAIN_REPLACE

	if [ "$CHECK_VALID_AGAIN_REPLACE" = "y" ]
	then
		echo

		# Drop orginal database
		echo -e "`date +%Y-%m-%d\ %H:%M:%S` - Drop the original \e[1m${DATABASE_NAME_SOURCE}\e[0m database"
		mysql --login-path=local --batch << EOF
-- Disable write to binary log
SET SESSION sql_log_bin=${DEACTIVATE_BINLOGS};

-- Drop database
DROP DATABASE IF EXISTS ${DATABASE_NAME_SOURCE};

-- Re-enable write to binary log
SET SESSION sql_log_bin=1;
EOF

		echo "`date +%Y-%m-%d\ %H:%M:%S` - Database dropped"
		echo

		# Rename temp database
		echo -e "`date +%Y-%m-%d\ %H:%M:%S` - Rename \e[1m${DATABASE_NAME_RESTORE}\e[0m database to \e[1m${DATABASE_NAME_SOURCE}\e[0m"

		# Re-create an empty database
		mysql --login-path=local --batch << EOF
-- Disable write to binary log
SET SESSION sql_log_bin=${ACTIVATE_BINLOGS};

-- Create database
CREATE DATABASE ${DATABASE_NAME_SOURCE};

-- Re-enable write to binary log
SET SESSION sql_log_bin=1;
EOF
		
		# Get tables list
		TABLES=`mysql --login-path=local --batch --skip-column-names --execute="SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='${DATABASE_NAME_RESTORE}'"`

		# Move each table
		for TABLE in ${TABLES}
		do
			mysql --login-path=local --batch << EOF
-- Disable write to binary log
SET SESSION sql_log_bin=${DEACTIVATE_BINLOGS};

-- Rename table
RENAME TABLE ${DATABASE_NAME_RESTORE}.${TABLE} to ${DATABASE_NAME_SOURCE}.${TABLE};

-- Re-enable write to binary log
SET SESSION sql_log_bin=${ACTIVATE_BINLOGS};
EOF
		done
		
		# Drop restore database
		mysql --login-path=local --batch --execute "DROP DATABASE IF EXISTS ${DATABASE_NAME_RESTORE};"

		echo "`date +%Y-%m-%d\ %H:%M:%S` - Database renamed"

		echo
		echo -e "If needed, you can now apply binlogs to perform pont-in-time recovery"
		echo "Ex: mysqlbinlog --database=<database> /<path>/binlog.000001 /<path>/binlog.000002 | mysql -u <user> -p<password>"
		echo "Below, the binlog file and position at dump time:"
		echo `getDumpMasterBinlogFile ${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}`
		echo `getDumpMasterBinlogPosition ${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}`
		echo
	else
		echo
		echo "Phew, that was close!"
		echo
	fi
else
	echo
	echo -e "Don't forget to drop \e[1m${DATABASE_NAME_RESTORE}\e[0m database when finished"
	echo
fi


# Ask for cleaning 
echo -e "We can clean \e[1;34m${DATABASE_TMP_PATH}\e[0m folder for you"
read -p "Are you OK? (y|n) " CHECK_VALID_CLEAN

# Check response
if [ "$CHECK_VALID_CLEAN" = "y" ]
then
	echo
	echo -e "`date +%Y-%m-%d\ %H:%M:%S` - Deleting \e[1m${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}\e[0m"
	rm -f ${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}
	echo -e "`date +%Y-%m-%d\ %H:%M:%S` - \e[1m${DATABASE_TMP_PATH}/${DATABASE_FILE_NAME_SQL}\e[0m deleted"
	echo
else
	echo
	echo -e "Don't forget to clean \e[1m${DATABASE_TMP_PATH}\e[0m folder when finished"
	echo
fi

